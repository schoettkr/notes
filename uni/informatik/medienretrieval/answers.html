<?xml version="1.0" encoding="utf-8"?>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-02-26 Wed 16:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="John Doe" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type='text/css'>
html {
  font-size: 62.5%;
  font-family: serif; }

body {
  font-size: 1.8rem;
  line-height: 1.618;
  max-width: 60%;
  margin: auto;
  color: #c9c9c9;
  background-color: #222222;
  padding: 13px; }

@media (max-width: 684px) {
  body {
    max-width: 98%;
    font-size: 1.53rem; } }

@media (max-width: 382px) {
  body {
    font-size: 1.35rem; } }

h1, h2, h3, h4, h5, h6 {
  line-height: 1.1;
  font-family: Verdana, Geneva, sans-serif;
  font-weight: 700;
  overflow-wrap: break-word;
  word-wrap: break-word;
  -ms-word-break: break-all;
  word-break: break-word;
  -ms-hyphens: auto;
  -moz-hyphens: auto;
  -webkit-hyphens: auto;
  hyphens: auto; }

h1 {
  font-size: 2.35em; }

h2 {
  font-size: 2.00em; }

h3 {
  font-size: 1.75em; }

h4 {
  font-size: 1.5em; }

h5 {
  font-size: 1.25em; }

h6 {
  font-size: 1em; }

small, sub, sup {
  font-size: 75%; }

hr {
  border-color: #ffffff; }

a {
  text-decoration: none;
  color: #ffffff; }
  a:hover {
    color: #c9c9c9;
    border-bottom: 2px solid #c9c9c9; }

ul {
  padding-left: 1.4em; }

li {
  margin-bottom: 0.4em; }

blockquote {
  font-style: italic;
  margin-left: 1.5em;
  padding-left: 1em;
  border-left: 3px solid #ffffff; }

img {
  max-width: 100%; }

/* Pre and Code */
pre {
  background-color: #4a4a4a;
  display: block;
  padding: 1em;
  overflow-x: auto; }

code {
  font-size: 0.9em;
  padding: 0 0.5em;
  background-color: #4a4a4a;
  white-space: pre-wrap; }

pre > code {
  padding: 0;
  background-color: transparent;
  white-space: pre; }

/* Tables */
table {
  text-align: justify;
  width: 100%;
  border-collapse: collapse; }

td, th {
  padding: 0.5em;
  border-bottom: 1px solid #4a4a4a; }

/* Buttons, forms and input */
input, textarea {
  border: 1px solid #c9c9c9; }
  input:focus, textarea:focus {
    border: 1px solid #ffffff; }

textarea {
  width: 100%; }

.button, button, input[type='submit'], input[type='reset'], input[type='button'] {
  display: inline-block;
  padding: 5px 10px;
  text-align: center;
  text-decoration: none;
  white-space: nowrap;
  background-color: #ffffff;
  color: #222222;
  border-radius: 1px;
  border: 1px solid #ffffff;
  cursor: pointer;
  box-sizing: border-box; }
  .button[disabled], button[disabled], input[type='submit'][disabled], input[type='reset'][disabled], input[type='button'][disabled] {
    cursor: default;
    opacity: .5; }
  .button:focus, .button:hover, button:focus, button:hover, input[type='submit']:focus, input[type='submit']:hover, input[type='reset']:focus, input[type='reset']:hover, input[type='button']:focus, input[type='button']:hover {
    background-color: #c9c9c9;
    border-color: #c9c9c9;
    color: #222222;
    outline: 0; }

textarea, select, input[type] {
  color: #c9c9c9;
  padding: 6px 10px;
  /* The 6px vertically centers text on FF, ignored by Webkit */
  margin-bottom: 10px;
  background-color: #4a4a4a;
  border: 1px solid #4a4a4a;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
  textarea:focus, select:focus, input[type]:focus {
    border: 1px solid #ffffff;
    outline: 0; }

input[type='checkbox']:focus {
  outline: 1px dotted #ffffff; }

label, legend, fieldset {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdd264e2">1. <span class="done DONE">DONE</span> Beschreiben Sie IDF und TF</a></li>
<li><a href="#org65c1999">2. <span class="done DONE">DONE</span> Erläutern Sie das Zipf&rsquo;sche Gesetz, die Luhn&rsquo;sche Termgewichtung und ihre praktische Bedeutung</a></li>
<li><a href="#org2b4dca8">3. <span class="done DONE">DONE</span> Beschreiben Sie die prinzipiellen Möglichkeiten des CBIR</a></li>
<li><a href="#org63770ae">4. <span class="done DONE">DONE</span> Welche Hauptmethoden der Stammformreduktion gibt es?</a></li>
<li><a href="#org58638cc">5. <span class="done DONE">DONE</span> Erläutern Sie den Unterschied zwischen N-Gram-Stemmern und Affix-Stemmern.</a></li>
<li><a href="#org0ede74b">6. <span class="done DONE">DONE</span> Erklären Sie die Maße Recall und Precision.</a></li>
<li><a href="#org4da17f7">7. <span class="done DONE">DONE</span> Beschreiben Sie Vorteile und Funktionsweise des twin-comparison-Verfahrens.</a></li>
<li><a href="#org1cfd691">8. <span class="todo TODO">TODO</span> Es existiert ein Retrievalsystem für Insektenbilder. Sie sollen eine Evaluation durchführen. Beschreiben Sie ihre Vorgehensweise.</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgdd264e2" class="outline-2">
<h2 id="orgdd264e2"><span class="section-number-2">1</span> <span class="done DONE">DONE</span> Beschreiben Sie IDF und TF</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Side note: In <b>jeder</b> Altklausur besteht die erste Aufgabe aus der Beschreibung von IDF. In einigen Klausuren wird zusätzlich noch die Beschreibung von TF verlangt</li>
</ul>

<p>
<b>Wikipedia Engl Summary</b><br />
In information retrieval, <b>tf–idf</b> or <b>TFIDF</b>, short for <b>term frequency–inverse document frequency</b>, is a numerical statistic that is intended to reflect how important a word is to a document in a collection or corpus. It is often used as a weighting factor in searches of information retrieval, text mining, and user modeling. The tf–idf value increases proportionally to the number of times a word appears in the document and is offset by the number of documents in the corpus that contain the word, which helps to adjust for the fact that some words appear more frequently in general. tf–idf is one of the most popular term-weighting schemes today; 83% of text-based recommender systems in digital libraries use tf–idf.
</p>

<p>
Variations of the tf–idf weighting scheme are often used by search engines as a central tool in scoring and ranking a document&rsquo;s relevance given a user query. tf–idf can be successfully used for stop-words filtering in various subject fields, including text summarization and classification.
</p>

<p>
One of the simplest ranking functions is computed by summing the tf–idf for each query term; many more sophisticated ranking functions are variants of this simple model.
</p>

<p>
<b>TF (Term Frequency)</b>: Suppose we have a set of English text documents and wish to rank which document is most relevant to the query, &ldquo;the brown cow&rdquo;. A simple way to start out is by eliminating documents that do not contain all three words &ldquo;the&rdquo;, &ldquo;brown&rdquo;, and &ldquo;cow&rdquo;, but this still leaves many documents. To further distinguish them, we might count the number of times each term occurs in each document; the number of times a term occurs in a document is called its term frequency. However, in the case where the length of documents varies greatly, adjustments are often made (see definition below). The first form of term weighting is due to Hans Peter Luhn (1957) which may be summarized as: <i>The weight of a term that occurs in a document is simply proportional to the term frequency.</i>
</p>

<p>
<b>IDF (Inverse Document Frequency)</b>: Because the term &ldquo;the&rdquo; is so common, term frequency will tend to incorrectly emphasize documents which happen to use the word &ldquo;the&rdquo; more frequently, without giving enough weight to the more meaningful terms &ldquo;brown&rdquo; and &ldquo;cow&rdquo;. The term &ldquo;the&rdquo; is not a good keyword to distinguish relevant and non-relevant documents and terms, unlike the less-common words &ldquo;brown&rdquo; and &ldquo;cow&rdquo;. Hence an inverse document frequency factor is incorporated which diminishes the weight of terms that occur very frequently in the document set and increases the weight of terms that occur rarely.
</p>

<p>
Karen Spärck Jones (1972) conceived a statistical interpretation of term specificity called Inverse Document Frequency (idf), which became a cornerstone of term weighting: <i>The specificity of a term can be quantified as an inverse function of the number of documents in which it occurs.</i>
</p>

<hr />

<p>
<b>Wikipedia Ger Summary</b><br />
Das Tf-idf-Maß (von englisch term frequency ‚Vorkommenshäufigkeit‘ und inverse document frequency ‚inverse Dokumenthäufigkeit‘) wird im Information Retrieval zur Beurteilung der Relevanz von Termen in Dokumenten einer Dokumentenkollektion eingesetzt.
</p>

<p>
Mit der so errechneten Gewichtung eines Wortes bezüglich des Dokuments, in welchem es enthalten ist, können Dokumente als Suchtreffer einer wortbasierten Suche besser in der Trefferliste angeordnet werden, als es beispielsweise über die Termfrequenz allein möglich wäre.
</p>

<p>
<b>IDF:</b> Die Inverse Dokumenthäufigkeit (englisch Inverse Document Frequency (IDF)) dient beim Information Retrieval zur Bestimmung der Trennfähigkeit eines Wortes bzw. Termes für die Indexierung von Dokumenten. Ein Wort, das nur in wenigen Dokumenten oft vorkommt, ist geeigneter als eines, das in fast jedem Dokument oder nur sehr gering auftritt. Zusammen mit der Termfrequenz (siehe Tf-idf-Maß) wird sie zur Gewichtung von Wörtern bei der Automatischen Indexierung eingesetzt.<br />
Die Inverse Dokumenthäufigkeit lässt sich berechnen als \[IDF_t = \log(\frac{N_D}{f_t})\]
wobei N<sub>D</sub> die Anzahl der Dokumente bezeichnet und f<sub>t</sub> die Anzahl der Dokumente, die den Term t enthalten. Wenn die Dokumentenhäufigkeit wächst, wird der Bruch kleiner.<br />
</p>

<p>
Die inverse Dokumenthäufigkeit misst die Spezifität eines Terms für die Gesamtmenge der betrachteten Dokumente. Ein übereinstimmendes Vorkommen von seltenen Begriffen ist für die Relevanz aussagekräftiger als eine Übereinstimmung bei sehr häufigen Worten (z. B. &ldquo;und&rdquo; oder &ldquo;ein&rdquo;).
Die inverse Dokumentfrequenz <code>idf(t)</code>  eines Terms <code>t</code> hängt nicht vom einzelnen Dokument, sondern vom Dokumentkorpus (der Gesamtmenge aller Dokumente im Retrievalszenario) ab.
</p>

<p>
<b>TF:</b> Die Vorkommenshäufigkeit (auch Suchwortdichte genannt) <code>#(t,D)</code> gibt an, wie häufig der Term <code>t</code> im Dokument <code>D</code> vorkommt. Ist beispielsweise das Dokument <code>D_{i}</code> der Satz
&ldquo;<i>Das rote Auto hält an der roten Ampel.</i>&rsquo;&rdquo; dann ist  <code>#(rot, D_i)=2</code>. Um eine Verzerrung des Ergebnisses in langen Dokumenten zu verhindern, ist es möglich, die absolute Vorkommenshäufigkeit <code>#(t,D)</code>  zu normalisieren. Dazu wird die Anzahl der Vorkommen von Term <code>t</code> in Dokument <code>D</code> durch die maximale Häufigkeit eines Terms in <code>D</code> geteilt und man erhält die relative Vorkommenshäufigkeit <code>tf(t,D)</code>.
</p>
</div>
</div>
<div id="outline-container-org65c1999" class="outline-2">
<h2 id="org65c1999"><span class="section-number-2">2</span> <span class="done DONE">DONE</span> Erläutern Sie das Zipf&rsquo;sche Gesetz, die Luhn&rsquo;sche Termgewichtung und ihre praktische Bedeutung</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist nur in 2 Altklausren.</li>
</ul>

<p>
<b>Zipfsch&rsquo;sches Gesetz</b>:
</p>
<ul class="org-ul">
<li>Zipf&rsquo;s law is an empirical law formulated using mathematical statistics that refers to the fact that many types of data studied in the physical and social sciences can be approximated with a Zipfian distribution, one of a family of related discrete power law probability distributions. Zipf distribution is related to the zeta distribution, but is not identical.</li>
<li>Zipf&rsquo;s law was originally formulated in terms of quantitative linguistics, stating that given some corpus of natural language utterances, the frequency of any word is inversely proportional to its rank in the frequency table. Thus the most frequent word will occur approximately twice as often as the second most frequent word, three times as often as the third most frequent word, etc.: the rank-frequency distribution is an inverse relation. For example, in the Brown Corpus of American English text, the word the is the most frequently occurring word, and by itself accounts for nearly 7% of all word occurrences (69,971 out of slightly over 1 million). True to Zipf&rsquo;s Law, the second-place word of accounts for slightly over 3.5% of words (36,411 occurrences), followed by and (28,852). Only 135 vocabulary items are needed to account for half the Brown Corpus.</li>
<li>Die vereinfachte Aussage des Zipfschen Gesetzes lautet: Wenn die Elemente einer Menge – beispielsweise die Wörter eines Textes – nach ihrer Häufigkeit geordnet werden, ist die Wahrscheinlichkeit p ihres Auftretens umgekehrt proportional zur Position n innerhalb der Rangfolge: \(p(n) \sim \frac{1}{n}.\)</li>
</ul>

<p>
<b>Luhn&rsquo;sche Termgewichtung</b>:
</p>
<ul class="org-ul">
<li>Token (Einzelne Wörter) werden statistisch nach Häufigkeit untersucht. Hochfrequenz Wörter bspw. the, of, to dabei abgeschnitten. Auf der anderen Seite kann man auch Wörter mit einer niedrigeren Frequenz abschneiden, aber dadurch besteht die Gefahr insbesondere sehr spezielle Terme zu vernachlässigen. Wird daher nicht of gemacht.</li>
<li>Terme in einem Dokument haben einen unterschiedlichen Stellenwert, für die meisten IR-Modelle gilt es daher einen quantitativen Ausdruck für die Wichtigkeit eines Term im Kontext eines Dokuments zu finden (=Termgewichtung).</li>
<li>Laut Luhn (1957) ist die Häufigkeit eines Terms in einem Text ein Maß für seine Relevanz. Jedoch besagt die These von Luhn <i>nicht</i>, dass Termhäufigkeit und Relevanz positiv miteinander korrelieren. Der Ansatz von einfacher Termhäufigkeit weist das Defizit auf, dass er alle Terme als gleichwichtig bei der Relevanzbetrachtung einordnet. Vielmehr wird ein Term, der in allen Dokumenten vorkommt als ein allgemeiner Term angesehen, weil er nicht zur Unterscheidung der Dokumente genutzt werden kann. Daher ist es nötig das Gewicht eines Term der in vielen Dokumenten vorkommt zu reduzieren, hierfür kann die TF-IDF genutzt werden (siehe oben)</li>
</ul>
</div>
</div>
<div id="outline-container-org2b4dca8" class="outline-2">
<h2 id="org2b4dca8"><span class="section-number-2">3</span> <span class="done DONE">DONE</span> Beschreiben Sie die prinzipiellen Möglichkeiten des CBIR</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist in 3 Altklausren.</li>
</ul>

<p>
Unter Content Based Image Retrieval (CBIR) versteht man eine inhaltsbasierte Bildersuche. Dabei handelt es sich um ein Spezialgebiet der Bildverarbeitung und des Wiederauffindens von Information (Information Retrieval) in großen Datenbeständen. „Inhaltsbasiert“ (content based) bedeutet dabei eine Analyse des aktuellen Inhaltes eines Bildes, also der Farben, Umrisse, Oberflächen (Texturen) oder anderer Informationen (sogenannte Merkmalsvektoren), die über eine automatische Bildverarbeitung ermittelt werden können. Die Aufgabe der Bildersuche ist es, eine Liste vorhandener Bilder so zu sortieren, dass die gesuchten Bilder (etwa anhand eines Referenzbildes) möglichst weit vorne stehen. Bilder werden anhand ihrer Ähnlichkeit zum Referenzbild sortiert, die sich durch eine Distanzfunktion und die Merkmalsvektoren der Bilder bestimmt. Ein Qualitätsmaß beurteilt die Sortierung, die maßgeblich von der Wahl der Merkmalsvektoren und des Ähnlichkeitsmaßes abhängt. Die inhaltsbasierte Bildersuche wird angewandt für Bilderdatenbanken, im Bereich der medizinischen Bildverarbeitung und bei der Suche nach Plagiaten (Near Duplicate Detection).
Im Bereich der Websuchmaschine, wird je nach Anbieter auch von &ldquo;reverser Bildersuche&rdquo; (reverse image search) oder einer &ldquo;visuellen Suchmaschine&rdquo; (visual search engine) gesprochen.
</p>

<p>
Type of Queries in Image Retrieval:
</p>
<ul class="org-ul">
<li>(query by text) &rarr; <b>*not content based</b> (CBIR)</li>
<li>Query by example</li>
<li>Query by sketch</li>
<li>Query by color</li>
<li>Query by texture</li>
</ul>

<p>
<b>Query By Example</b> is a query technique that involves providing the CBIR system with an example image that it will then base its search upon. The underlying search algorithms may vary depending on the application, but result images should all share common elements with the provided example. Options for providing example images to the system include:
</p>
<ul class="org-ul">
<li>A preexisting image may be supplied by the user or chosen from a random set.</li>
<li>The user draws a rough approximation of the image they are looking for, for example with blobs of color or general shapes.</li>
</ul>
<p>
This query technique removes the difficulties that can arise when trying to describe images with words.<br />
</p>

<p>
<b>Semantic retrieval</b> starts with a user making a request like &ldquo;find pictures of Abraham Lincoln&rdquo;. This type of open-ended task is very difficult for computers to perform - Lincoln may not always be facing the camera or in the same pose. Many CBIR systems therefore generally make use of lower-level features like texture, color, and shape. These features are either used in combination with interfaces that allow easier input of the criteria or with databases that have already been trained to match features (such as faces, fingerprints, or shape matching). However, in general, image retrieval requires human feedback in order to identify higher-level concepts.
</p>

<p>
Other query methods include browsing for example images, navigating customized/hierarchical categories, querying by image region (rather than the entire image), querying by multiple example images, querying by visual sketch, querying by direct specification of image features, and multimodal queries (e.g. combining touch, voice, etc.).
</p>

<p>
The most common method for comparing two images in content-based image retrieval (typically an example image and an image from the database) is using an image distance measure. An image distance measure compares the similarity of two images in various dimensions such as color, texture, shape, and others. For example, a distance of 0 signifies an exact match with the query, with respect to the dimensions that were considered. As one may intuitively gather, a value greater than 0 indicates various degrees of similarities between the images. Search results then can be sorted based on their distance to the queried image. Many measures of image distance (Similarity Models) have been developed. Most commonly distance computing measures are based on <b>color</b>, <b>texture</b> or <b>shape</b>.
</p>

<p>
<b>Color</b><br />
Computing distance measures based on color similarity is achieved by computing a color histogram for each image that identifies the proportion of pixels within an image holding specific values. Examining images based on the colors they contain is one of the most widely used techniques because it can be completed without regard to image size or orientation. However, research has also attempted to segment color proportion by region and by spatial relationship among several color regions.
</p>

<p>
<b>Texture</b><br />
Texture measures look for visual patterns in images and how they are spatially defined. Textures are represented by texels which are then placed into a number of sets, depending on how many textures are detected in the image. These sets not only define the texture, but also where in the image the texture is located.<br />
Texture is a difficult concept to represent. The identification of specific textures in an image is achieved primarily by modeling texture as a two-dimensional gray level variation. The relative brightness of pairs of pixels is computed such that degree of contrast, regularity, coarseness and directionality may be estimated. The problem is in identifying patterns of co-pixel variation and associating them with particular classes of textures such as silky, or rough.<br />
Other methods of classifying textures include:
</p>
<ul class="org-ul">
<li>Co-occurrence matrix, Laws texture energy, Wavelet transform, Orthogonal transforms (Discrete Tchebichef moments)</li>
</ul>

<p>
<b>Shape</b><br />
Shape does not refer to the shape of an image but to the shape of a particular region that is being sought out. Shapes will often be determined first applying segmentation or edge detection to an image. Other methods use shape filters to identify given shapes of an image. Shape descriptors may also need to be invariant to translation, rotation, and scale. Some shape descriptors include:
</p>
<ul class="org-ul">
<li>Fourier transform</li>
<li>Moment invariant</li>
</ul>


<p>
Measures of image retrieval can be defined in terms of precision and recall. However, there are other methods being considered.<br />
An image is retrieved in CBIR system by adopting several techniques simultaneously such as Integrating Pixel Cluster Indexing, histogram intersection and discrete wavelet transform methods.<br />
Machine learning and application of iterative techniques are becoming more common in CBIR.
</p>
</div>
</div>

<div id="outline-container-org63770ae" class="outline-2">
<h2 id="org63770ae"><span class="section-number-2">4</span> <span class="done DONE">DONE</span> Welche Hauptmethoden der Stammformreduktion gibt es?</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist in 4 Altklausuren und zwar immer dann, wenn die Frage nach N-Gram-Stemmern und Affix-Stemmern nicht auftritt (selbes Thema).</li>
<li>Alternativ: Nennen Sie 3 Arten von Stemmern.</li>
</ul>

<p>
Es gibt prinzipiell 3 Arten von Stemmern (Stammformreduktion):
</p>
<ul class="org-ul">
<li>dictionary-based stemmers</li>
<li>n-gram stemmers</li>
<li>affix stemmers</li>
</ul>
<p>
N-Gram-Stemmer und Affix-Stemmer zählen zur Kategorie der algorithmischen Stemmer.<br />
Affix Stemmer beziehen sich wie der Name schon sagt grundsätzlich auf sogenannte Affixe. Zu Affixen zählen Prefixe (<i>un/happy), Infixe (ein/ge/schoben) und Suffixe (fit/ted</i>).
Klassische Affix-Stemmer sind zB der Porter Stemmer, der Snowball Stemmer und Krovetz (Kstem). Der Porter Stemmer arbeitet beispielsweise mit Vokal-Konsonant-Folgen um Suffixe zu entfernen.<br />
Ein dictionary-based stemmer (zB Hunspell) definiert einen sogennanten dictionary mit dessen Hilfe sich Wortvariationen auf die jeweiligen Stämme reduzieren lassen. Dafür legt er mehrere &ldquo;Regeln&rdquo; fest.<br />
Ein N-Gramm ist das Ergebnis einer Wortzerlegung in einzelne, jeweils zu N-aufeinanderfolgende Fragmente zusammengefasst. Ein 2-gram stemmer bezieht sich auf sogenannte Bigramme also Fragmente die aus zwei Zeichen bestehen, ein 3-gram stemmer hingegen auf Trigramme undsoweiter. Um somit die Ähnlichkeit von bestimmten Termen zu bestimmen werden die Worte beispielsweise in ihre Trigramme zerlegt und anschließend wird die Distanz zwischen den Worten über ihre Fragemente berechnet.<br />
</p>
</div>
</div>
<div id="outline-container-org58638cc" class="outline-2">
<h2 id="org58638cc"><span class="section-number-2">5</span> <span class="done DONE">DONE</span> Erläutern Sie den Unterschied zwischen N-Gram-Stemmern und Affix-Stemmern.</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist in 3 Altklausren und zwar immer dann, wenn die Frage nach Hauptmethoden der Stammformreduktion nicht auftritt (selbes Thema).</li>
</ul>
<p>
Zur Beantwortung dieser Frage, siehe vorherige Frage.
</p>
</div>
</div>
<div id="outline-container-org0ede74b" class="outline-2">
<h2 id="org0ede74b"><span class="section-number-2">6</span> <span class="done DONE">DONE</span> Erklären Sie die Maße Recall und Precision.</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist nur in 2 Altklausuren.</li>
</ul>

<p>
Recall (Trefferquote) und Precision (Genauigkeit, Präzision) sind Maße zur Evaluierung Information Retrieval Systemen. Es geht hier primär darum die Relevanz von gefundenen Informationen/Dokumenten zu beurteilen. Die Trefferquote gibt den Anteil der bei einer Suche gefundenen relevanten Dokumente und damit die Vollständigkeit eines Suchergebnisses an. Die Genauigkeit beschreibt mit dem Anteil relevanter Dokumente an der Ergebnismenge die Genauigkeit eines Suchergebnisses. Der (weniger gebräuchliche) Ausfall bezeichnet den Anteil gefundener irrelevanter Dokumente an der Gesamtmenge aller irrelevanten Dokumente, er gibt also in negativer Weise an, wie gut irrelevante Dokumente im Suchergebnis vermieden werden.<br />
Statt als Maß können Recall und Precision und Fallout auch als Wahrscheinlichkeit interpretiert werden:
</p>
<ul class="org-ul">
<li>Recall/Trefferquote ist die Wahrscheinlichkeit, mit der ein relevantes Dokument gefunden wird (Sensitivität)</li>
<li>Precision/Genauigkeit ist die Wahrscheinlichkeit, mit der ein gefundenes Dokument relevant ist (Positiver Vorhersagewert)</li>
<li>Ausfall ist die Wahrscheinlichkeit, mit der ein irrelevantes Dokument gefunden wird (Falsch-positiv-Rate).</li>
</ul>
<p>
Eine gute Recherche sollte möglichst alle relevanten Dokumente finden (richtig positiv) und die nicht relevanten Dokumente nicht finden (richtig negativ). Wie oben beschrieben, hängen die verschiedenen Maße jedoch voneinander ab. Im Allgemeinen sinkt mit steigender Trefferrate die Genauigkeit (mehr irrelevante Ergebnisse). Umgekehrt sinkt mit steigender Genauigkeit (weniger irrelevante Ergebnisse) die Trefferrate (mehr relevante Dokumente, die nicht gefunden werden). Je nach Anwendungsfall sind die unterschiedlichen Maße zur Beurteilung mehr oder weniger relevant.
</p>

<p>
<b>Beispiel</b><br />
In einer Datenbank mit 36 Dokumenten sind zu einer Suchanfrage 20 Dokumente relevant und 16 nicht relevant. Eine Suche liefert 12 Dokumente, von denen tatsächlich 8 relevant sind.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Relevant</th>
<th scope="col" class="org-left">Nicht-relevant</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Gefunden</td>
<td class="org-left"><span style='background-color:lightgreen'>8</td>
<td class="org-left"><span style='background-color:tomato'>4</td>
</tr>

<tr>
<td class="org-left">Nicht gefunden</td>
<td class="org-left">12</td>
<td class="org-left"><span style='background-color:gold'>8</td>
</tr>
</tbody>
</table>

<p>
Recall und Precision für die konkrete Suche ergeben sich aus den Werten der Konfusionsmatrix:
</p>
<ul class="org-ul">
<li>Recall(Trefferquote) = \(\frac{8}{8+12} =  \frac{8}{20} = \frac{2}{5} = 0.4\)</li>
<li>Precision(Genauigkeit) = \(\frac{8}{8+4} =  \frac{8}{12} = \frac{2}{3} = 0.67\)</li>
<li>Fallout (Abfallquote) = \(\frac{4}{4+12} =  \frac{4}{16} = \frac{1}{4} = 0.25\)</li>
</ul>

<p>
Ein Problem bei der Berechnung der Trefferquote ist die Tatsache, dass man nur selten weiß, wie viele relevante Dokumente insgesamt existieren und nicht gefunden wurden (Problem der unvollständigen Wahrheitsmatrix). Bei größeren Datenbanken, bei denen die Berechnung der absoluten Trefferquote besonders schwierig ist, wird deswegen mit der relativen Trefferquote gearbeitet. Dabei wird die gleiche Suche mit mehreren Suchmaschinen durchgeführt, und die jeweils neuen relevanten Treffer werden zu den nicht gefundenen relevanten Dokumenten addiert. Mit der Rückfangmethode kann abgeschätzt werden, wie viele relevante Dokumente insgesamt existieren.
</p>

<p>
Problematisch ist auch, dass zur Bestimmung von Trefferquote und Genauigkeit die Relevanz eines Dokumentes als Wahrheitswert (ja/nein) bekannt sein muss. In der Praxis ist jedoch oft die Subjektive Relevanz von Bedeutung. Auch für in einer Rangordnung angeordnete Treffermengen ist die Angabe von Trefferquote und Genauigkeit oft nicht ausreichend, da es nicht nur darauf ankommt, ob ein relevantes Dokument gefunden wird, sondern auch, ob es im Vergleich zu nicht relevanten Dokumenten genügend hoch in der Rangfolge eingeordnet wird. Bei sehr unterschiedlich großen Treffermengen kann die Angabe durchschnittlicher Werte für Trefferquote und Genauigkeit irreführend sein.
</p>

<ul class="org-ul">
<li>do not work independantly
<ul class="org-ul">
<li>recall increases with amout of retrieved documents</li>
<li>increasing recall -&gt; decreasing precision</li>
</ul></li>
<li>importance depends on context
<ul class="org-ul">
<li>expert systems, file search: Recall optimized</li>
<li>web: precision-optimized</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org4da17f7" class="outline-2">
<h2 id="org4da17f7"><span class="section-number-2">7</span> <span class="done DONE">DONE</span> Beschreiben Sie Vorteile und Funktionsweise des twin-comparison-Verfahrens.</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist in 3 Altklausuren.</li>
<li>The twin-comparison algorithm uses the difference between consecutive frames to detect a cut, and the accumulated difference over a sequence of frames to detect gradual transitions</li>
<li><a href="http://www.cad.zju.edu.cn/home/zhx/DAM/2013/lib/exe/fetch.php?media=pdf:dam2013-15.pdf">http://www.cad.zju.edu.cn/home/zhx/DAM/2013/lib/exe/fetch.php?media=pdf:dam2013-15.pdf</a></li>
<li><a href="http://www.cse.unsw.edu.au/~cs9519/lecture_notes_08/L11_COMP9519.pdf">http://www.cse.unsw.edu.au/~cs9519/lecture_notes_08/L11_COMP9519.pdf</a></li>
</ul>

<p>
Bei der Videoklassifikation ist das Ziel einzelne Szenen aufgrund ihrer Inhalte in bestimmte Kategorien zu unterteilen. Zusammenfassend setzt sich die Videoklassifikation aus mehreren Schritten zusammen. Ausgehend von einem Video wird zunächst eine zeitliche Segmentierung vorgenommen, um anschließend aus einzelnen Sequenzen audiovisuelle Merkmale zu extrahieren. Anhand dieser Informationen und geeigneter Klassifikationsmodelle erfolgt eine Klassifikation von Shots, die abschließend zu Szenen gruppiert werden. Bei der zeitlichen Segmentierung wird ein Video wird in mehrere Shots unterteilt, wobei eine solche Sequenz aus mehrere aufeinander folgende Frames aus einer Kameraperspektive besteht. Es wird angenommen, dass innerhalb dieser Shots wenige inhaltliche Veränderungen
auftreten, wodurch die Beschreibung erleichtert wird. Abhängig von der semantischen Bedeutung bilden mehrere <i>benachbarte Shots</i> eine Szene. Um die benötigten Shots zu bestimmen, gilt es die Grenzen zwischen den einzelnen Sequenzen zu detektieren, wobei verschiedene Arten von Übergängen auftreten können. Basierend auf den Eigenschaften der einzelnen Übergangseffekte existiert bereits eine Vielzahl
an Algorithmen zur Detektion von Shots, wobei entweder pixel-, regionen- oder bewegungsbasierte Informationen herangezogen werden. Ein weit verbreiteter Ansatz zur <b>zeitlichen Segmentierung</b> ist <i>Twin Comparison</i>.<br />
Im Allgemeinen wird bei der Twin-Comparison-Methode zwischen der Detektion von abrupten Schnitten und fortlaufenden Übergängen (Ein-, Aus- und Überblendung) unterschieden. Während Schnitte aufgrund bedeutender inhaltlicher Veränderungen zwischen zwei Frames einfach zu detektieren sind, treten bei fortlaufenden Übergängen über mehrere Frames nur geringe Änderungen auf, wodurch eine Detektion erschwert wird. Die Detektion der verschiedenen Übergänge erfolgt durch die Analyse von benachbarten Frames und deren Differenzen. Für diese Auswertung können sowohl einzelne Pixel, beschränkte Regionen oder globale Histogramme herangezogen werden, wobei histogrammbasierte Methoden aufgrund des guten Kompromisses zwischen Berechnungsaufwand und Genauigkeit am häufigsten verwendet werden.<br />
Ausgehend von einzelnen Frames wird zunächst für jedes Bild ein Histogramm gebildet, indem die Intensitätswerte der Farbkanäle einer Quantisierung unterzogen werden. Anschließend gilt es, die Differenz von benachbarten Frames zu berechnen. Je größer die Histogramm-Differenz von benachbarten Frames ausfällt, desto größer ist die inhaltliche Veränderung. Basierend auf den Eigenschaften von <b>abrupten Schnitten</b> und der Annahme, dass zwei verschiedene Shots unterschiedlichen Inhalt aufweisen, wird ein Schnitt detektiert, sobald die Differenz einen Schwellwert \(T_h\) übersteigt.<br />
Fortlaufende Übergänge können auf ähnliche Weise bestimmt werden. Aufgrund der Überlagerung von zwei benachbarten Shots fällt der inhaltliche Unterschied während des Überganges geringer aus als im Falle eines direkten Schnitts. Jedoch ist die Histogramm-Differenz von Framepaaren innerhalb eines Shots am geringsten. Deshalb wird ein zweiter Schwellwert \(T_l\) eingeführt, mit dessen Hilfe Fades, Dissolves und Wipes detektiert werden können. Übersteigt die Differenz von benachbarten Frames den Schwellwert \(T_l\) , so handelt es sich dabei um den möglichen Beginn eines fortlaufenden Überganges. Anschließend werden die Differenzen von nachfolgenden Framepaaren betrachtet, bis \(T_l\) unterschritten wird und das Ende des Übergangseffekts eintritt. Die einzelnen Differenzwerte innerhalb dieses Bereichs werden aufsummiert. Überschreitet die Summe den Schwellwert zur Schnitterkennung \(T_h\), so wird angenommen, dass es sich dabei tatsächlich um einen fortlaufenden Übergang handelt.<br />
Diese Methode zur Detektion von Shot-Grenzen wird aufgrund der beiden eingesetzten Schwellwerte als Twin Comparison bezeichnet und ist in der Lage sowohl Schnitte als auch spezielle Übergangseffekte zu detektieren (Einblendung, Ausblendung, Abrupter Schnitt, Dissolve, Wipe, Fade)
</p>
</div>
</div>
<div id="outline-container-org1cfd691" class="outline-2">
<h2 id="org1cfd691"><span class="section-number-2">8</span> <span class="todo TODO">TODO</span> Es existiert ein Retrievalsystem für Insektenbilder. Sie sollen eine Evaluation durchführen. Beschreiben Sie ihre Vorgehensweise.</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>Side note: Diese Aufgabe ist in <b>jeder</b> Altklausur und sie bringt immer die meisten Punkte</li>
<li><a href="https://nlp.stanford.edu/IR-book/pdf/08eval.pdf">https://nlp.stanford.edu/IR-book/pdf/08eval.pdf</a></li>
</ul>

<p>
Zunächst einmal gilt es herauszufinden in welchem Kontext das Retrievalsystem benutzt wird bzw. was das konkrete Einsatzgebiet ist. Grundsätzlich lässt sich ein Retrievalsystem mit Hilfe von den Maßen Recall und Precicision evaluieren. Doch da diese Maße prinzipiell gegeneinander verlaufen, ist es wichtig zu definieren wie sich die Relevanz für das spezifische Einsatzgebiet ergibt und welcher Informationsbedarf besteht. Ohne das der konkrete Informationsbedarf festgelegt ist ließe sich das Insekten-IRS kaum evaluieren. Aus dem Informationsbedarf lässt sich die Relevanz der Ergebnisse die das IRS erzielt, ableiten.
</p>

<p>
ImageCLEF - a continuing track of the Cross Language Evaluation Forum that evaluates systems using both textual and pure-image retrieval methods.
Content-based Access of Image and Video Libraries - a series of IEEE workshops from 1998 to 2001.
</p>

<ul class="org-ul">
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.211.7111&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.211.7111&amp;rep=rep1&amp;type=pdf</a></li>
<li><a href="https://link.springer.com/content/pdf/10.1007%2F3-540-48762-X_65.pdf">https://link.springer.com/content/pdf/10.1007%2F3-540-48762-X_65.pdf</a></li>
<li><a href="https://pdfs.semanticscholar.org/0754/3d661cc0abef2e5ffa9ad2031c6131c5a740.pdf">https://pdfs.semanticscholar.org/0754/3d661cc0abef2e5ffa9ad2031c6131c5a740.pdf</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: John Doe</p>
<p class="date">Created: 2020-02-26 Wed 16:53</p>
</div>
</body>
</html>
